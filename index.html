<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Defender 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
            color: #fff;
        }
        
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            pointer-events: none;
        }
        
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 16px;
        }
        
        #score {
            font-size: 24px;
            font-weight: bold;
            color: #0f0;
        }
        
        #health-bar {
            margin-top: 10px;
            width: 200px;
            height: 20px;
            background-color: #333;
            border-radius: 10px;
            overflow: hidden;
        }
        
        #health-fill {
            height: 100%;
            width: 100%;
            background-color: #0f0;
            transition: width 0.3s;
        }
        
        #ammo {
            margin-top: 5px;
            font-size: 16px;
        }
        
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            display: none;
            pointer-events: auto;
        }
        
        #game-over h2 {
            font-size: 36px;
            color: #f00;
            margin-bottom: 20px;
        }
        
        #final-score {
            font-size: 24px;
            margin-bottom: 20px;
        }
        
        button {
            background-color: #0066cc;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 18px;
            border-radius: 5px;
            cursor: pointer;
            pointer-events: auto;
        }
        
        button:hover {
            background-color: #0055aa;
        }
        
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        #start-screen h1 {
            font-size: 48px;
            color: #0f0;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #0f0;
        }
        
        #start-screen p {
            font-size: 18px;
            margin-bottom: 30px;
            max-width: 600px;
            text-align: center;
            line-height: 1.5;
        }
        
        #controls {
            background-color: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 30px;
            text-align: left;
        }
        
        #controls h3 {
            margin-bottom: 10px;
            color: #0f0;
        }
        
        #fps-counter {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px;
            border-radius: 3px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div id="hud">
            <div>Score: <span id="score">0</span></div>
            <div>Health:</div>
            <div id="health-bar">
                <div id="health-fill"></div>
            </div>
            <div id="ammo">Ammo: <span id="ammo-count">30</span></div>
        </div>
        
        <div id="fps-counter">FPS: 0</div>
        
        <div id="game-over">
            <h2>Game Over</h2>
            <div id="final-score">Score: 0</div>
            <button id="restart-button">Play Again</button>
        </div>
    </div>
    
    <div id="start-screen">
        <h1>Space Defender 3D</h1>
        <p>Defend Earth from incoming asteroids! Destroy as many as you can before they hit you.</p>
        
        <div id="controls">
            <h3>Controls:</h3>
            <p>Mouse - Aim<br>
            Left Click - Shoot<br>
            W/A/S/D - Move ship<br>
            Space - Reload<br>
            Shift - Boost speed</p>
        </div>
        
        <button id="start-button">Start Game</button>
    </div>

    <script>
        // Game state
        const gameState = {
            score: 0,
            health: 100,
            ammo: 30,
            maxAmmo: 30,
            isGameOver: false,
            isGameStarted: false,
            asteroids: [],
            bullets: [],
            particles: [],
            stars: [],
            lastShot: 0,
            shotCooldown: 200, // ms
            reloading: false,
            reloadTime: 1500, // ms
            reloadStart: 0,
            playerVelocity: { x: 0, y: 0, z: 0 },
            playerPosition: { x: 0, y: 0, z: 0 },
            cameraRotation: { x: 0, y: 0 },
            isBoosting: false,
            lastAsteroidSpawn: 0,
            asteroidSpawnRate: 1500, // ms
            difficulty: 1
        };

        // Initialize WebGL
        const canvas = document.getElementById('gameCanvas');
        const gl = canvas.getContext('webgl');
        
        if (!gl) {
            alert('WebGL not supported in your browser. Please use a modern browser like Chrome or Firefox.');
            throw new Error('WebGL not supported');
        }
        
        // Set canvas size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // Shader programs
        const vsSource = `
            attribute vec4 aVertexPosition;
            attribute vec4 aVertexColor;
            attribute vec3 aVertexNormal;
            
            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            uniform mat4 uNormalMatrix;
            uniform vec3 uLightDirection;
            uniform bool uUseLight;
            
            varying lowp vec4 vColor;
            
            void main(void) {
                gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
                
                if (uUseLight) {
                    // Apply lighting
                    vec3 transformedNormal = normalize((uNormalMatrix * vec4(aVertexNormal, 0.0)).xyz);
                    float directional = max(dot(transformedNormal, uLightDirection), 0.0);
                    vec4 lighting = vec4(0.3, 0.3, 0.3, 1.0) + vec4(directional, directional, directional, 0.0);
                    vColor = aVertexColor * lighting;
                } else {
                    vColor = aVertexColor;
                }
            }
        `;
        
        const fsSource = `
            precision mediump float;
            varying lowp vec4 vColor;
            
            void main(void) {
                gl_FragColor = vColor;
            }
        `;
        
        // Initialize shader program
        function initShaderProgram(gl, vsSource, fsSource) {
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
            
            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                return null;
            }
            
            return shaderProgram;
        }
        
        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }
        
        const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
        
        const programInfo = {
            program: shaderProgram,
            attribLocations: {
                vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                vertexColor: gl.getAttribLocation(shaderProgram, 'aVertexColor'),
                vertexNormal: gl.getAttribLocation(shaderProgram, 'aVertexNormal'),
            },
            uniformLocations: {
                projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
                modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
                normalMatrix: gl.getUniformLocation(shaderProgram, 'uNormalMatrix'),
                lightDirection: gl.getUniformLocation(shaderProgram, 'uLightDirection'),
                useLight: gl.getUniformLocation(shaderProgram, 'uUseLight'),
            },
        };
        
        // Create spaceship model
        function createSpaceship() {
            // Simplified spaceship model
            const positions = [
                // Front nose
                0.0, 0.0, -2.0,    // 0: nose tip
                -0.5, -0.3, -1.0,  // 1: bottom left
                0.5, -0.3, -1.0,   // 2: bottom right
                0.0, 0.3, -1.0,    // 3: top
                
                // Body
                -0.7, -0.3, 0.0,   // 4: body bottom left
                0.7, -0.3, 0.0,    // 5: body bottom right
                -0.5, 0.3, 0.0,    // 6: body top left
                0.5, 0.3, 0.0,     // 7: body top right
                
                // Wings
                -1.5, -0.3, 0.5,   // 8: left wing tip
                1.5, -0.3, 0.5,    // 9: right wing tip
                
                // Rear
                -0.5, -0.3, 1.0,   // 10: rear bottom left
                0.5, -0.3, 1.0,    // 11: rear bottom right
                -0.3, 0.2, 1.0,    // 12: rear top left
                0.3, 0.2, 1.0,     // 13: rear top right
                0.0, -0.3, 1.5,    // 14: engine
            ];
            
            const faceColors = [
                [0.7, 0.7, 0.9, 1.0],  // Front nose top
                [0.6, 0.6, 0.8, 1.0],  // Front nose left
                [0.6, 0.6, 0.8, 1.0],  // Front nose right
                
                [0.5, 0.5, 0.7, 1.0],  // Body top
                [0.4, 0.4, 0.6, 1.0],  // Body left
                [0.4, 0.4, 0.6, 1.0],  // Body right
                [0.3, 0.3, 0.5, 1.0],  // Body bottom
                
                [0.6, 0.2, 0.2, 1.0],  // Left wing
                [0.6, 0.2, 0.2, 1.0],  // Right wing
                
                [0.3, 0.3, 0.5, 1.0],  // Rear top
                [0.2, 0.2, 0.4, 1.0],  // Rear left
                [0.2, 0.2, 0.4, 1.0],  // Rear right
                [0.2, 0.2, 0.4, 1.0],  // Rear bottom
                
                [0.7, 0.3, 0.1, 1.0],  // Engine
            ];
            
            const indices = [
                // Front nose
                0, 1, 3,
                0, 3, 2,
                0, 2, 1,
                
                // Body top
                3, 6, 7,
                3, 7, 2,
                
                // Body left
                1, 4, 6,
                1, 6, 3,
                
                // Body right
                2, 7, 5,
                2, 5, 1,
                
                // Body bottom
                1, 5, 4,
                
                // Left wing
                4, 8, 6,
                
                // Right wing
                5, 7, 9,
                
                // Rear top
                6, 12, 13,
                6, 13, 7,
                
                // Rear left
                6, 10, 12,
                
                // Rear right
                7, 13, 11,
                
                // Rear bottom
                10, 11, 14,
                
                // Engine
                10, 14, 12,
                11, 13, 14,
            ];
            
            // Calculate normals
            const normals = calculateNormals(positions, indices);
            
            // Create colors array
            let colors = [];
            let colorIndex = 0;
            
            for (let i = 0; i < positions.length / 3; i++) {
                const color = faceColors[Math.min(colorIndex, faceColors.length - 1)];
                if (i % 4 === 0 && i > 0) colorIndex++;
                colors = colors.concat(color);
            }
            
            // Create buffers
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            
            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
            
            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
            
            const normalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
            
            return {
                position: positionBuffer,
                color: colorBuffer,
                indices: indexBuffer,
                normal: normalBuffer,
                vertexCount: indices.length,
            };
        }
        
        // Create asteroid model
        function createAsteroid(size = 1.0, detail = 20) {
            const positions = [];
            const indices = [];
            const baseRadius = size;
            
            // Generate a sphere with random variations
            for (let i = 0; i <= detail; i++) {
                const theta = i * Math.PI / detail;
                const sinTheta = Math.sin(theta);
                const cosTheta = Math.cos(theta);
                
                for (let j = 0; j <= detail; j++) {
                    const phi = j * 2 * Math.PI / detail;
                    const sinPhi = Math.sin(phi);
                    const cosPhi = Math.cos(phi);
                    
                    // Add random bumps to make it look like an asteroid
                    const noise = 0.2 * baseRadius * (Math.random() - 0.5);
                    const radius = baseRadius + noise;
                    
                    const x = radius * sinTheta * cosPhi;
                    const y = radius * sinTheta * sinPhi;
                    const z = radius * cosTheta;
                    
                    positions.push(x, y, z);
                }
            }
            
            // Generate indices for the triangles
            for (let i = 0; i < detail; i++) {
                for (let j = 0; j < detail; j++) {
                    const first = i * (detail + 1) + j;
                    const second = first + detail + 1;
                    
                    indices.push(first, second, first + 1);
                    indices.push(second, second + 1, first + 1);
                }
            }
            
            // Calculate normals
            const normals = calculateNormals(positions, indices);
            
            // Create colors - gray with random variations
            let colors = [];
            for (let i = 0; i < positions.length / 3; i++) {
                const grayValue = 0.3 + 0.3 * Math.random();
                colors.push(grayValue, grayValue * 0.9, grayValue * 0.8, 1.0);
            }
            
            // Create buffers
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            
            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
            
            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
            
            const normalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
            
            return {
                position: positionBuffer,
                color: colorBuffer,
                indices: indexBuffer,
                normal: normalBuffer,
                vertexCount: indices.length,
            };
        }
        
        // Create bullet model
        function createBullet() {
            // Simple bullet as a small sphere
            const positions = [];
            const indices = [];
            const detail = 8;
            const radius = 0.1;
            
            // Generate a sphere
            for (let i = 0; i <= detail; i++) {
                const theta = i * Math.PI / detail;
                const sinTheta = Math.sin(theta);
                const cosTheta = Math.cos(theta);
                
                for (let j = 0; j <= detail; j++) {
                    const phi = j * 2 * Math.PI / detail;
                    const sinPhi = Math.sin(phi);
                    const cosPhi = Math.cos(phi);
                    
                    const x = radius * sinTheta * cosPhi;
                    const y = radius * sinTheta * sinPhi;
                    const z = radius * cosTheta;
                    
                    positions.push(x, y, z);
                }
            }
            
            // Generate indices for the triangles
            for (let i = 0; i < detail; i++) {
                for (let j = 0; j < detail; j++) {
                    const first = i * (detail + 1) + j;
                    const second = first + detail + 1;
                    
                    indices.push(first, second, first + 1);
                    indices.push(second, second + 1, first + 1);
                }
            }
            
            // Calculate normals
            const normals = calculateNormals(positions, indices);
            
            // Create colors - bright yellow/orange for bullets
            let colors = [];
            for (let i = 0; i < positions.length / 3; i++) {
                colors.push(1.0, 0.8, 0.2, 1.0);
            }
            
            // Create buffers
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            
            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
            
            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
            
            const normalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
            
            return {
                position: positionBuffer,
                color: colorBuffer,
                indices: indexBuffer,
                normal: normalBuffer,
                vertexCount: indices.length,
            };
        }
        
        // Create particle model (for explosions)
        function createParticle() {
            // Simple particle as a tiny cube
            const positions = [
                // Front face
                -0.05, -0.05,  0.05,
                 0.05, -0.05,  0.05,
                 0.05,  0.05,  0.05,
                -0.05,  0.05,  0.05,
                
                // Back face
                -0.05, -0.05, -0.05,
                -0.05,  0.05, -0.05,
                 0.05,  0.05, -0.05,
                 0.05, -0.05, -0.05,
                
                // Top face
                -0.05,  0.05, -0.05,
                -0.05,  0.05,  0.05,
                 0.05,  0.05,  0.05,
                 0.05,  0.05, -0.05,
                
                // Bottom face
                -0.05, -0.05, -0.05,
                 0.05, -0.05, -0.05,
                 0.05, -0.05,  0.05,
                -0.05, -0.05,  0.05,
                
                // Right face
                 0.05, -0.05, -0.05,
                 0.05,  0.05, -0.05,
                 0.05,  0.05,  0.05,
                 0.05, -0.05,  0.05,
                
                // Left face
                -0.05, -0.05, -0.05,
                -0.05, -0.05,  0.05,
                -0.05,  0.05,  0.05,
                -0.05,  0.05, -0.05,
            ];
            
            const indices = [
                0,  1,  2,      0,  2,  3,    // front
                4,  5,  6,      4,  6,  7,    // back
                8,  9,  10,     8,  10, 11,   // top
                12, 13, 14,     12, 14, 15,   // bottom
                16, 17, 18,     16, 18, 19,   // right
                20, 21, 22,     20, 22, 23,   // left
            ];
            
            // Calculate normals
            const normals = calculateNormals(positions, indices);
            
            // Create colors - will be set dynamically
            let colors = [];
            for (let i = 0; i < positions.length / 3; i++) {
                colors.push(1.0, 0.5, 0.0, 1.0); // Default orange
            }
            
            // Create buffers
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            
            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
            
            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
            
            const normalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
            
            return {
                position: positionBuffer,
                color: colorBuffer,
                indices: indexBuffer,
                normal: normalBuffer,
                vertexCount: indices.length,
            };
        }
        
        // Create star model (background)
        function createStar() {
            // Simple star as a point
            const positions = [0.0, 0.0, 0.0];
            
            // Create colors - white
            const colors = [1.0, 1.0, 1.0, 1.0];
            
            // Create buffers
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            
            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
            
            return {
                position: positionBuffer,
                color: colorBuffer,
                vertexCount: 1,
            };
        }
        
        // Calculate normals for lighting
        function calculateNormals(positions, indices) {
            const normals = new Array(positions.length).fill(0);
            
            // For each face (triangle)
            for (let i = 0; i < indices.length; i += 3) {
                const idx1 = indices[i] * 3;
                const idx2 = indices[i + 1] * 3;
                const idx3 = indices[i + 2] * 3;
                
                // Get vertices of the triangle
                const v1 = [positions[idx1], positions[idx1 + 1], positions[idx1 + 2]];
                const v2 = [positions[idx2], positions[idx2 + 1], positions[idx2 + 2]];
                const v3 = [positions[idx3], positions[idx3 + 1], positions[idx3 + 2]];
                
                // Calculate vectors for the edges
                const edge1 = [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]];
                const edge2 = [v3[0] - v1[0], v3[1] - v1[1], v3[2] - v1[2]];
                
                // Calculate the cross product to get the normal
                const normal = [
                    edge1[1] * edge2[2] - edge1[2] * edge2[1],
                    edge1[2] * edge2[0] - edge1[0] * edge2[2],
                    edge1[0] * edge2[1] - edge1[1] * edge2[0]
                ];
                
                // Normalize the normal
                const length = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1] + normal[2] * normal[2]);
                normal[0] /= length;
                normal[1] /= length;
                normal[2] /= length;
                
                // Add the normal to each vertex of the triangle
                normals[idx1] += normal[0];
                normals[idx1 + 1] += normal[1];
                normals[idx1 + 2] += normal[2];
                
                normals[idx2] += normal[0];
                normals[idx2 + 1] += normal[1];
                normals[idx2 + 2] += normal[2];
                
                normals[idx3] += normal[0];
                normals[idx3 + 1] += normal[1];
                normals[idx3 + 2] += normal[2];
            }
            
            // Normalize all the normals
            for (let i = 0; i < normals.length; i += 3) {
                const length = Math.sqrt(
                    normals[i] * normals[i] +
                    normals[i + 1] * normals[i + 1] +
                    normals[i + 2] * normals[i + 2]
                );
                
                if (length > 0) {
                    normals[i] /= length;
                    normals[i + 1] /= length;
                    normals[i + 2] /= length;
                }
            }
            
            return normals;
        }
        
        // Matrix math functions
        const mat4 = {
            create: function() {
                return new Float32Array([
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ]);
            },
            
            perspective: function(out, fovy, aspect, near, far) {
                const f = 1.0 / Math.tan(fovy / 2);
                const nf = 1 / (near - far);
                
                out[0] = f / aspect;
                out[1] = 0;
                out[2] = 0;
                out[3] = 0;
                out[4] = 0;
                out[5] = f;
                out[6] = 0;
                out[7] = 0;
                out[8] = 0;
                out[9] = 0;
                out[10] = (far + near) * nf;
                out[11] = -1;
                out[12] = 0;
                out[13] = 0;
                out[14] = (2 * far * near) * nf;
                out[15] = 0;
                
                return out;
            },
            
            identity: function(out) {
                out[0] = 1;
                out[1] = 0;
                out[2] = 0;
                out[3] = 0;
                out[4] = 0;
                out[5] = 1;
                out[6] = 0;
                out[7] = 0;
                out[8] = 0;
                out[9] = 0;
                out[10] = 1;
                out[11] = 0;
                out[12] = 0;
                out[13] = 0;
                out[14] = 0;
                out[15] = 1;
                return out;
            },
            
            translate: function(out, a, v) {
                const x = v[0], y = v[1], z = v[2];
                
                out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
                out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
                out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
                out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
                
                return out;
            },
            
            rotate: function(out, a, rad, axis) {
                let x = axis[0], y = axis[1], z = axis[2];
                let len = Math.sqrt(x * x + y * y + z * z);
                
                if (len < 0.000001) { return null; }
                
                len = 1 / len;
                x *= len;
                y *= len;
                z *= len;
                
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const t = 1 - c;
                
                const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                
                // Construct rotation matrix
                const b00 = x * x * t + c;
                const b01 = y * x * t + z * s;
                const b02 = z * x * t - y * s;
                const b10 = x * y * t - z * s;
                const b11 = y * y * t + c;
                const b12 = z * y * t + x * s;
                const b20 = x * z * t + y * s;
                const b21 = y * z * t - x * s;
                const b22 = z * z * t + c;
                
                // Perform rotation
                out[0] = a00 * b00 + a10 * b01 + a20 * b02;
                out[1] = a01 * b00 + a11 * b01 + a21 * b02;
                out[2] = a02 * b00 + a12 * b01 + a22 * b02;
                out[3] = a03 * b00 + a13 * b01 + a23 * b02;
                out[4] = a00 * b10 + a10 * b11 + a20 * b12;
                out[5] = a01 * b10 + a11 * b11 + a21 * b12;
                out[6] = a02 * b10 + a12 * b11 + a22 * b12;
                out[7] = a03 * b10 + a13 * b11 + a23 * b12;
                out[8] = a00 * b20 + a10 * b21 + a20 * b22;
                out[9] = a01 * b20 + a11 * b21 + a21 * b22;
                out[10] = a02 * b20 + a12 * b21 + a22 * b22;
                out[11] = a03 * b20 + a13 * b21 + a23 * b22;
                
                if (a !== out) {
                    out[12] = a[12];
                    out[13] = a[13];
                    out[14] = a[14];
                    out[15] = a[15];
                }
                
                return out;
            },
            
            invert: function(out, a) {
                const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                const a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
                
                const b00 = a00 * a11 - a01 * a10;
                const b01 = a00 * a12 - a02 * a10;
                const b02 = a00 * a13 - a03 * a10;
                const b03 = a01 * a12 - a02 * a11;
                const b04 = a01 * a13 - a03 * a11;
                const b05 = a02 * a13 - a03 * a12;
                const b06 = a20 * a31 - a21 * a30;
                const b07 = a20 * a32 - a22 * a30;
                const b08 = a20 * a33 - a23 * a30;
                const b09 = a21 * a32 - a22 * a31;
                const b10 = a21 * a33 - a23 * a31;
                const b11 = a22 * a33 - a23 * a32;
                
                // Calculate determinant
                let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
                
                if (!det) {
                    return null;
                }
                
                det = 1.0 / det;
                
                out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
                out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
                out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
                out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
                out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
                out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
                out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
                out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
                out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
                out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
                out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
                out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
                out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
                out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
                out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
                out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
                
                return out;
            }
        };
        
        // Initialize models
        const spaceshipModel = createSpaceship();
        const asteroidModel = createAsteroid();
        const bulletModel = createBullet();
        const particleModel = createParticle();
        const starModel = createStar();
        
        // Generate stars for the background
        function generateStars(count) {
            for (let i = 0; i < count; i++) {
                const distance = 50 + Math.random() * 50;
                const angle = Math.random() * Math.PI * 2;
                const elevation = Math.random() * Math.PI - Math.PI / 2;
                
                const x = distance * Math.cos(angle) * Math.cos(elevation);
                const y = distance * Math.sin(elevation);
                const z = distance * Math.sin(angle) * Math.cos(elevation);
                
                const size = 0.05 + Math.random() * 0.1;
                const brightness = 0.5 + Math.random() * 0.5;
                
                gameState.stars.push({
                    x, y, z,
                    size,
                    brightness,
                    twinkle: Math.random() * 0.2,
                    twinkleSpeed: 0.5 + Math.random() * 2,
                    twinkleOffset: Math.random() * Math.PI * 2
                });
            }
        }
        
        // Spawn a new asteroid
        function spawnAsteroid() {
            const distance = 30;
            const angle = Math.random() * Math.PI * 2;
            const elevation = (Math.random() - 0.5) * Math.PI * 0.5;
            
            const x = distance * Math.cos(angle) * Math.cos(elevation);
            const y = distance * Math.sin(elevation);
            const z = distance * Math.sin(angle) * Math.cos(elevation);
            
            const size = 0.5 + Math.random() * 1.5 * gameState.difficulty;
            
            // Calculate velocity towards player with some randomness
            const speed = 0.05 + Math.random() * 0.05 * gameState.difficulty;
            const dirX = -x;
            const dirY = -y;
            const dirZ = -z;
            
            // Normalize direction
            const length = Math.sqrt(dirX * dirX + dirY * dirY + dirZ * dirZ);
            
            const velocityX = (dirX / length) * speed;
            const velocityY = (dirY / length) * speed;
            const velocityZ = (dirZ / length) * speed;
            
            // Random rotation
            const rotationX = (Math.random() - 0.5) * 0.02;
            const rotationY = (Math.random() - 0.5) * 0.02;
            const rotationZ = (Math.random() - 0.5) * 0.02;
            
            gameState.asteroids.push({
                x, y, z,
                velocityX, velocityY, velocityZ,
                rotationX, rotationY, rotationZ,
                size,
                rotation: {
                    x: Math.random() * Math.PI * 2,
                    y: Math.random() * Math.PI * 2,
                    z: Math.random() * Math.PI * 2
                },
                health: size * 10
            });
        }
        
        // Fire a bullet
        function fireBullet() {
            if (gameState.ammo <= 0 || gameState.reloading) return;
            
            // Calculate bullet direction based on camera rotation
            const dirX = Math.sin(gameState.cameraRotation.y) * Math.cos(gameState.cameraRotation.x);
            const dirY = Math.sin(gameState.cameraRotation.x);
            const dirZ = Math.cos(gameState.cameraRotation.y) * Math.cos(gameState.cameraRotation.x);
            
            // Bullet speed
            const speed = 0.5;
            
            gameState.bullets.push({
                x: gameState.playerPosition.x,
                y: gameState.playerPosition.y,
                z: gameState.playerPosition.z,
                velocityX: dirX * speed,
                velocityY: dirY * speed,
                velocityZ: dirZ * speed,
                timeLeft: 60 // Frames until bullet disappears
            });
            
            gameState.ammo--;
            document.getElementById('ammo-count').textContent = gameState.ammo;
            
            // Play sound
            playSound('shoot');
        }
        
        // Create explosion particles
        function createExplosion(x, y, z, size, count) {
            for (let i = 0; i < count; i++) {
                // Random direction
                const angle = Math.random() * Math.PI * 2;
                const elevation = Math.random() * Math.PI - Math.PI / 2;
                const speed = 0.05 + Math.random() * 0.1;
                
                const dirX = Math.cos(angle) * Math.cos(elevation);
                const dirY = Math.sin(elevation);
                const dirZ = Math.sin(angle) * Math.cos(elevation);
                
                // Random color (orange to red)
                const r = 0.8 + Math.random() * 0.2;
                const g = 0.2 + Math.random() * 0.4;
                const b = 0.0 + Math.random() * 0.2;
                
                gameState.particles.push({
                    x, y, z,
                    velocityX: dirX * speed,
                    velocityY: dirY * speed,
                    velocityZ: dirZ * speed,
                    size: size * (0.1 + Math.random() * 0.2),
                    color: [r, g, b, 1.0],
                    timeLeft: 30 + Math.random() * 30
                });
            }
        }
        
        // Check collision between bullet and asteroid
        function checkBulletAsteroidCollision(bullet, asteroid) {
            const dx = bullet.x - asteroid.x;
            const dy = bullet.y - asteroid.y;
            const dz = bullet.z - asteroid.z;
            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
            
            return distance < asteroid.size;
        }
        
        // Check collision between player and asteroid
        function checkPlayerAsteroidCollision(asteroid) {
            const dx = gameState.playerPosition.x - asteroid.x;
            const dy = gameState.playerPosition.y - asteroid.y;
            const dz = gameState.playerPosition.z - asteroid.z;
            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
            
            return distance < asteroid.size + 1.0; // Player ship size + buffer
        }
        
        // Audio system
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const sounds = {
            shoot: {
                play: function() {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(110, audioContext.currentTime + 0.1);
                    
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.1);
                }
            },
            explosion: {
                play: function() {
                    const noise = audioContext.createBufferSource();
                    const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.5, audioContext.sampleRate);
                    const data = buffer.getChannelData(0);
                    
                    for (let i = 0; i < buffer.length; i++) {
                        data[i] = Math.random() * 2 - 1;
                    }
                    
                    const gainNode = audioContext.createGain();
                    gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    
                    const filter = audioContext.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(1000, audioContext.currentTime);
                    filter.frequency.exponentialRampToValueAtTime(20, audioContext.currentTime + 0.5);
                    
                    noise.buffer = buffer;
                    noise.connect(filter);
                    filter.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    noise.start();
                    noise.stop(audioContext.currentTime + 0.5);
                }
            },
            hit: {
                play: function() {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(220, audioContext.currentTime + 0.05);
                    
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.05);
                }
            },
            playerHit: {
                play: function() {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(110, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(55, audioContext.currentTime + 0.3);
                    
                    gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.3);
                }
            },
            reload: {
                play: function() {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(880, audioContext.currentTime + 0.2);
                    
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.2);
                }
            }
        };
        
        function playSound(name) {
            if (sounds[name]) {
                sounds[name].play();
            }
        }
        
        // Draw the scene
        function drawScene(gl, programInfo, deltaTime) {
            gl.clearColor(0.0, 0.0, 0.05, 1.0);  // Almost black background
            gl.clearDepth(1.0);
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);
            
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            
            // Create perspective matrix
            const fieldOfView = 45 * Math.PI / 180;
            const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
            const zNear = 0.1;
            const zFar = 100.0;
            const projectionMatrix = mat4.create();
            
            mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);
            
            // Set up camera based on player position and rotation
            const viewMatrix = mat4.create();
            mat4.identity(viewMatrix);
            
            // Apply camera rotation (first person view)
            mat4.rotate(viewMatrix, viewMatrix, gameState.cameraRotation.x, [1, 0, 0]);
            mat4.rotate(viewMatrix, viewMatrix, gameState.cameraRotation.y, [0, 1, 0]);
            
            // Apply camera position (inverse of player position)
            mat4.translate(viewMatrix, viewMatrix, [
                -gameState.playerPosition.x,
                -gameState.playerPosition.y,
                -gameState.playerPosition.z
            ]);
            
            // Draw stars (background)
            gl.disable(gl.DEPTH_TEST);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
            
            gameState.stars.forEach(star => {
                const modelViewMatrix = mat4.create();
                mat4.identity(modelViewMatrix);
                
                // Apply star position
                mat4.translate(modelViewMatrix, modelViewMatrix, [star.x, star.y, star.z]);
                
                // Calculate twinkle effect
                const time = Date.now() / 1000;
                const twinkle = star.brightness + Math.sin(time * star.twinkleSpeed + star.twinkleOffset) * star.twinkle;
                
                // Set up point size for stars
                gl.vertexAttrib1f(gl.POINT_SIZE, star.size * 2);
                
                // Tell WebGL how to pull out the positions from the position buffer
                gl.bindBuffer(gl.ARRAY_BUFFER, starModel.position);
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexPosition,
                    3,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );
                gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
                
                // Tell WebGL how to pull out the colors from the color buffer
                gl.bindBuffer(gl.ARRAY_BUFFER, starModel.color);
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexColor,
                    4,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );
                gl.enableVertexAttribArray(programInfo.attribLocations.vertexColor);
                
                // Tell WebGL to use our program when drawing
                gl.useProgram(programInfo.program);
                
                // Set the shader uniforms
                gl.uniformMatrix4fv(
                    programInfo.uniformLocations.projectionMatrix,
                    false,
                    projectionMatrix
                );
                gl.uniformMatrix4fv(
                    programInfo.uniformLocations.modelViewMatrix,
                    false,
                    modelViewMatrix
                );
                gl.uniform1i(programInfo.uniformLocations.useLight, false);
                
                // Draw the star
                gl.drawArrays(gl.POINTS, 0, 1);
            });
            
            gl.disable(gl.BLEND);
            gl.enable(gl.DEPTH_TEST);
            
            // Set light direction for all objects
            const lightDirection = [0.5, 1.0, 0.5];
            const normalizedLight = [];
            const length = Math.sqrt(
                lightDirection[0] * lightDirection[0] +
                lightDirection[1] * lightDirection[1] +
                lightDirection[2] * lightDirection[2]
            );
            
            normalizedLight[0] = lightDirection[0] / length;
            normalizedLight[1] = lightDirection[1] / length;
            normalizedLight[2] = lightDirection[2] / length;
            
            // Draw spaceship (only visible parts in third person view)
            if (!gameState.isFirstPerson) {
                const modelViewMatrix = mat4.create();
                mat4.identity(modelViewMatrix);
                
                // Position the spaceship
                mat4.translate(modelViewMatrix, modelViewMatrix, [
                    gameState.playerPosition.x,
                    gameState.playerPosition.y,
                    gameState.playerPosition.z
                ]);
                
                // Rotate the spaceship based on camera rotation
                mat4.rotate(modelViewMatrix, modelViewMatrix, gameState.cameraRotation.y, [0, 1, 0]);
                mat4.rotate(modelViewMatrix, modelViewMatrix, gameState.cameraRotation.x, [1, 0, 0]);
                
                // Calculate normal matrix for lighting
                const normalMatrix = mat4.create();
                mat4.invert(normalMatrix, modelViewMatrix);
                
                // Tell WebGL how to pull out the positions from the position buffer
                gl.bindBuffer(gl.ARRAY_BUFFER, spaceshipModel.position);
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexPosition,
                    3,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );
                gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
                
                // Tell WebGL how to pull out the colors from the color buffer
                gl.bindBuffer(gl.ARRAY_BUFFER, spaceshipModel.color);
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexColor,
                    4,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );
                gl.enableVertexAttribArray(programInfo.attribLocations.vertexColor);
                
                // Tell WebGL how to pull out the normals from the normal buffer
                gl.bindBuffer(gl.ARRAY_BUFFER, spaceshipModel.normal);
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexNormal,
                    3,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );
                gl.enableVertexAttribArray(programInfo.attribLocations.vertexNormal);
                
                // Tell WebGL which indices to use to index the vertices
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, spaceshipModel.indices);
                
                // Tell WebGL to use our program when drawing
                gl.useProgram(programInfo.program);
                
                // Set the shader uniforms
                gl.uniformMatrix4fv(
                    programInfo.uniformLocations.projectionMatrix,
                    false,
                    projectionMatrix
                );
                gl.uniformMatrix4fv(
                    programInfo.uniformLocations.modelViewMatrix,
                    false,
                    modelViewMatrix
                );
                gl.uniformMatrix4fv(
                    programInfo.uniformLocations.normalMatrix,
                    false,
                    normalMatrix
                );
                gl.uniform3fv(
                    programInfo.uniformLocations.lightDirection,
                    normalizedLight
                );
                gl.uniform1i(programInfo.uniformLocations.useLight, true);
                
                // Draw the spaceship
                gl.drawElements(gl.TRIANGLES, spaceshipModel.vertexCount, gl.UNSIGNED_SHORT, 0);
            }
            
            // Draw asteroids
            gameState.asteroids.forEach(asteroid => {
                const modelViewMatrix = mat4.create();
                mat4.identity(modelViewMatrix);
                
                // Position the asteroid
                mat4.translate(modelViewMatrix, modelViewMatrix, [asteroid.x, asteroid.y, asteroid.z]);
                
                // Rotate the asteroid
                mat4.rotate(modelViewMatrix, modelViewMatrix, asteroid.rotation.x, [1, 0, 0]);
                mat4.rotate(modelViewMatrix, modelViewMatrix, asteroid.rotation.y, [0, 1, 0]);
                mat4.rotate(modelViewMatrix, modelViewMatrix, asteroid.rotation.z, [0, 0, 1]);
                
                // Scale the asteroid
                const scaleMatrix = mat4.create();
                mat4.identity(scaleMatrix);
                mat4.scale(scaleMatrix, scaleMatrix, [asteroid.size, asteroid.size, asteroid.size]);
                
                // Combine matrices
                mat4.multiply(modelViewMatrix, modelViewMatrix, scaleMatrix);
                
                // Calculate normal matrix for lighting
                const normalMatrix = mat4.create();
                mat4.invert(normalMatrix, modelViewMatrix);
                
                // Tell WebGL how to pull out the positions from the position buffer
                gl.bindBuffer(gl.ARRAY_BUFFER, asteroidModel.position);
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexPosition,
                    3,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );
                gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
                
                // Tell WebGL how to pull out the colors from the color buffer
                gl.bindBuffer(gl.ARRAY_BUFFER, asteroidModel.color);
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexColor,
                    4,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );
                gl.enableVertexAttribArray(programInfo.attribLocations.vertexColor);
                
                // Tell WebGL how to pull out the normals from the normal buffer
                gl.bindBuffer(gl.ARRAY_BUFFER, asteroidModel.normal);
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexNormal,
                    3,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );
                gl.enableVertexAttribArray(programInfo.attribLocations.vertexNormal);
                
                // Tell WebGL which indices to use to index the vertices
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, asteroidModel.indices);
                
                // Tell WebGL to use our program when drawing
                gl.useProgram(programInfo.program);
                
                // Set the shader uniforms
                gl.uniformMatrix4fv(
                    programInfo.uniformLocations.projectionMatrix,
                    false,
                    projectionMatrix
                );
                gl.uniformMatrix4fv(
                    programInfo.uniformLocations.modelViewMatrix,
                    false,
                    modelViewMatrix
                );
                gl.uniformMatrix4fv(
                    programInfo.uniformLocations.normalMatrix,
                    false,
                    normalMatrix
                );
                gl.uniform3fv(
                    programInfo.uniformLocations.lightDirection,
                    normalizedLight
                );
                gl.uniform1i(programInfo.uniformLocations.useLight, true);
                
                // Draw the asteroid
                gl.drawElements(gl.TRIANGLES, asteroidModel.vertexCount, gl.UNSIGNED_SHORT, 0);
            });
            
            // Draw bullets
            gameState.bullets.forEach(bullet => {
                const modelViewMatrix = mat4.create();
                mat4.identity(modelViewMatrix);
                
                // Position the bullet
                mat4.translate(modelViewMatrix, modelViewMatrix, [bullet.x, bullet.y, bullet.z]);
                
                // Tell WebGL how to pull out the positions from the position buffer
                gl.bindBuffer(gl.ARRAY_BUFFER, bulletModel.position);
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexPosition,
                    3,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );
                gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
                
                // Tell WebGL how to pull out the colors from the color buffer
                gl.bindBuffer(gl.ARRAY_BUFFER, bulletModel.color);
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexColor,
                    4,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );
                gl.enableVertexAttribArray(programInfo.attribLocations.vertexColor);
                
                // Tell WebGL how to pull out the normals from the normal buffer
                gl.bindBuffer(gl.ARRAY_BUFFER, bulletModel.normal);
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexNormal,
                    3,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );
                gl.enableVertexAttribArray(programInfo.attribLocations.vertexNormal);
                
                // Tell WebGL which indices to use to index the vertices
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bulletModel.indices);
                
                // Tell WebGL to use our program when drawing
                gl.useProgram(programInfo.program);
                
                // Set the shader uniforms
                gl.uniformMatrix4fv(
                    programInfo.uniformLocations.projectionMatrix,
                    false,
                    projectionMatrix
                );
                gl.uniformMatrix4fv(
                    programInfo.uniformLocations.modelViewMatrix,
                    false,
                    modelViewMatrix
                );
                gl.uniform1i(programInfo.uniformLocations.useLight, false);
                
                // Draw the bullet
                gl.drawElements(gl.TRIANGLES, bulletModel.vertexCount, gl.UNSIGNED_SHORT, 0);
            });
            
            // Draw particles (with blending for transparency)
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
            gl.depthMask(false);
            
            gameState.particles.forEach(particle => {
                const modelViewMatrix = mat4.create();
                mat4.identity(modelViewMatrix);
                
                // Position the particle
                mat4.translate(modelViewMatrix, modelViewMatrix, [particle.x, particle.y, particle.z]);
                
                // Scale the particle
                const scaleMatrix = mat4.create();
                mat4.identity(scaleMatrix);
                mat4.scale(scaleMatrix, scaleMatrix, [particle.size, particle.size, particle.size]);
                
                // Combine matrices
                mat4.multiply(modelViewMatrix, modelViewMatrix, scaleMatrix);
                
                // Create colors array with particle color
                const colors = [];
                for (let i = 0; i < 24; i++) { // 24 vertices in the cube
                    colors.push(...particle.color);
                }
                
                // Update color buffer
                gl.bindBuffer(gl.ARRAY_BUFFER, particleModel.color);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.DYNAMIC_DRAW);
                
                // Tell WebGL how to pull out the positions from the position buffer
                gl.bindBuffer(gl.ARRAY_BUFFER, particleModel.position);
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexPosition,
                    3,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );
                gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
                
                // Tell WebGL how to pull out the colors from the color buffer
                gl.bindBuffer(gl.ARRAY_BUFFER, particleModel.color);
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexColor,
                    4,
                    gl.FLOAT,
                    false,
                    0,
                    0
                );
                gl.enableVertexAttribArray(programInfo.attribLocations.vertexColor);
                
                // Tell WebGL which indices to use to index the vertices
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, particleModel.indices);
                
                // Tell WebGL to use our program when drawing
                gl.useProgram(programInfo.program);
                
                // Set the shader uniforms
                gl.uniformMatrix4fv(
                    programInfo.uniformLocations.projectionMatrix,
                    false,
                    projectionMatrix
                );
                gl.uniformMatrix4fv(
                    programInfo.uniformLocations.modelViewMatrix,
                    false,
                    modelViewMatrix
                );
                gl.uniform1i(programInfo.uniformLocations.useLight, false);
                
                // Draw the particle
                gl.drawElements(gl.TRIANGLES, particleModel.vertexCount, gl.UNSIGNED_SHORT, 0);
            });
            
            gl.depthMask(true);
            gl.disable(gl.BLEND);
        }
        
        // Update game state
        function updateGameState(deltaTime) {
            // Update player position based on velocity
            gameState.playerPosition.x += gameState.playerVelocity.x * deltaTime;
            gameState.playerPosition.y += gameState.playerVelocity.y * deltaTime;
            gameState.playerPosition.z += gameState.playerVelocity.z * deltaTime;
            
            // Apply friction to slow down player
            const friction = 0.95;
            gameState.playerVelocity.x *= friction;
            gameState.playerVelocity.y *= friction;
            gameState.playerVelocity.z *= friction;
            
            // Update asteroid positions and rotations
            gameState.asteroids.forEach(asteroid => {
                asteroid.x += asteroid.velocityX * deltaTime * 60;
                asteroid.y += asteroid.velocityY * deltaTime * 60;
                asteroid.z += asteroid.velocityZ * deltaTime * 60;
                
                asteroid.rotation.x += asteroid.rotationX * deltaTime * 60;
                asteroid.rotation.y += asteroid.rotationY * deltaTime * 60;
                asteroid.rotation.z += asteroid.rotationZ * deltaTime * 60;
            });
            
            // Update bullet positions and lifetimes
            for (let i = gameState.bullets.length - 1; i >= 0; i--) {
                const bullet = gameState.bullets[i];
                
                bullet.x += bullet.velocityX * deltaTime * 60;
                bullet.y += bullet.velocityY * deltaTime * 60;
                bullet.z += bullet.velocityZ * deltaTime * 60;
                
                bullet.timeLeft--;
                
                if (bullet.timeLeft <= 0) {
                    gameState.bullets.splice(i, 1);
                }
            }
            
            // Update particle positions and lifetimes
            for (let i = gameState.particles.length - 1; i >= 0; i--) {
                const particle = gameState.particles[i];
                
                particle.x += particle.velocityX * deltaTime * 60;
                particle.y += particle.velocityY * deltaTime * 60;
                particle.z += particle.velocityZ * deltaTime * 60;
                
                particle.timeLeft--;
                
                // Fade out particles
                if (particle.timeLeft < 10) {
                    particle.color[3] = particle.timeLeft / 10;
                }
                
                if (particle.timeLeft <= 0) {
                    gameState.particles.splice(i, 1);
                }
            }
            
            // Check for bullet-asteroid collisions
            for (let i = gameState.bullets.length - 1; i >= 0; i--) {
                const bullet = gameState.bullets[i];
                
                for (let j = gameState.asteroids.length - 1; j >= 0; j--) {
                    const asteroid = gameState.asteroids[j];
                    
                    if (checkBulletAsteroidCollision(bullet, asteroid)) {
                        // Reduce asteroid health
                        asteroid.health -= 10;
                        
                        // Remove bullet
                        gameState.bullets.splice(i, 1);
                        
                        // Create hit effect
                        createExplosion(bullet.x, bullet.y, bullet.z, 0.2, 5);
                        
                        // Play hit sound
                        playSound('hit');
                        
                        // If asteroid is destroyed
                        if (asteroid.health <= 0) {
                            // Create explosion
                            createExplosion(asteroid.x, asteroid.y, asteroid.z, asteroid.size, 20);
                            
                            // Play explosion sound
                            playSound('explosion');
                            
                            // Add score based on asteroid size
                            gameState.score += Math.floor(asteroid.size * 10);
                            document.getElementById('score').textContent = gameState.score;
                            
                            // Remove asteroid
                            gameState.asteroids.splice(j, 1);
                            
                            // Increase difficulty over time
                            gameState.difficulty += 0.01;
                        }
                        
                        break;
                    }
                }
            }
            
            // Check for player-asteroid collisions
            for (let i = gameState.asteroids.length - 1; i >= 0; i--) {
                const asteroid = gameState.asteroids[i];
                
                if (checkPlayerAsteroidCollision(asteroid)) {
                    // Create explosion
                    createExplosion(asteroid.x, asteroid.y, asteroid.z, asteroid.size, 20);
                    
                    // Play hit sound
                    playSound('playerHit');
                    
                    // Reduce player health based on asteroid size
                    gameState.health -= Math.floor(asteroid.size * 10);
                    
                    // Update health bar
                    document.getElementById('health-fill').style.width = `${gameState.health}%`;
                    
                    // Change health bar color based on health
                    if (gameState.health < 30) {
                        document.getElementById('health-fill').style.backgroundColor = '#f00';
                    } else if (gameState.health < 60) {
                        document.getElementById('health-fill').style.backgroundColor = '#ff0';
                    }
                    
                    // Remove asteroid
                    gameState.asteroids.splice(i, 1);
                    
                    // Check if game over
                    if (gameState.health <= 0) {
                        gameOver();
                    }
                }
            }
            
            // Spawn new asteroids
            const now = Date.now();
            if (now - gameState.lastAsteroidSpawn > gameState.asteroidSpawnRate / gameState.difficulty) {
                spawnAsteroid();
                gameState.lastAsteroidSpawn = now;
            }
            
            // Handle reloading
            if (gameState.reloading) {
                const reloadProgress = (now - gameState.reloadStart) / gameState.reloadTime;
                
                if (reloadProgress >= 1) {
                    gameState.reloading = false;
                    gameState.ammo = gameState.maxAmmo;
                    document.getElementById('ammo-count').textContent = gameState.ammo;
                    playSound('reload');
                } else {
                    document.getElementById('ammo-count').textContent = `Reloading... ${Math.floor(reloadProgress * 100)}%`;
                }
            }
        }
        
        // Game over function
        function gameOver() {
            gameState.isGameOver = true;
            document.getElementById('game-over').style.display = 'block';
            document.getElementById('final-score').textContent = `Score: ${gameState.score}`;
        }
        
        // Restart game function
        function restartGame() {
            // Reset game state
            gameState.score = 0;
            gameState.health = 100;
            gameState.ammo = gameState.maxAmmo;
            gameState.isGameOver = false;
            gameState.asteroids = [];
            gameState.bullets = [];
            gameState.particles = [];
            gameState.playerVelocity = { x: 0, y: 0, z: 0 };
            gameState.playerPosition = { x: 0, y: 0, z: 0 };
            gameState.lastAsteroidSpawn = Date.now();
            gameState.difficulty = 1;
            
            // Update UI
            document.getElementById('score').textContent = '0';
            document.getElementById('health-fill').style.width = '100%';
            document.getElementById('health-fill').style.backgroundColor = '#0f0';
            document.getElementById('ammo-count').textContent = gameState.ammo;
            document.getElementById('game-over').style.display = 'none';
        }
        
        // Start game function
        function startGame() {
            gameState.isGameStarted = true;
            document.getElementById('start-screen').style.display = 'none';
            
            // Lock pointer for mouse control
            canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
            canvas.requestPointerLock();
            
            // Generate stars
            generateStars(200);
            
            // Start audio context (needed for Chrome)
            audioContext.resume();
        }
        
        // Game loop variables
        let then = 0;
        let frameCount = 0;
        let lastFpsUpdate = 0;
        let fps = 0;
        
        // Main game loop
        function render(now) {
            now *= 0.001;  // convert to seconds
            const deltaTime = Math.min(0.1, now - then);  // Cap delta time to avoid large jumps
            then = now;
            
            // Update FPS counter
            frameCount++;
            if (now - lastFpsUpdate >= 1.0) {
                fps = frameCount;
                frameCount = 0;
                lastFpsUpdate = now;
                document.getElementById('fps-counter').textContent = `FPS: ${fps}`;
            }
            
            if (gameState.isGameStarted && !gameState.isGameOver) {
                // Update game state
                updateGameState(deltaTime);
            }
            
            // Draw the scene
            drawScene(gl, programInfo, deltaTime);
            
            // Request next frame
            requestAnimationFrame(render);
        }
        
        // Start the game loop
        requestAnimationFrame(render);
        
        // Event listeners
        document.addEventListener('keydown', (event) => {
            if (!gameState.isGameStarted || gameState.isGameOver) return;
            
            const speed = gameState.isBoosting ? 0.03 : 0.015;
            
            switch (event.key.toLowerCase()) {
                case 'w':
                    // Move forward
                    gameState.playerVelocity.x += Math.sin(gameState.cameraRotation.y) * Math.cos(gameState.cameraRotation.x) * speed;
                    gameState.playerVelocity.y += Math.sin(gameState.cameraRotation.x) * speed;
                    gameState.playerVelocity.z += Math.cos(gameState.cameraRotation.y) * Math.cos(gameState.cameraRotation.x) * speed;
                    break;
                case 's':
                    // Move backward
                    gameState.playerVelocity.x -= Math.sin(gameState.cameraRotation.y) * Math.cos(gameState.cameraRotation.x) * speed;
                    gameState.playerVelocity.y -= Math.sin(gameState.cameraRotation.x) * speed;
                    gameState.playerVelocity.z -= Math.cos(gameState.cameraRotation.y) * Math.cos(gameState.cameraRotation.x) * speed;
                    break;
                case 'a':
                    // Strafe left
                    gameState.playerVelocity.x -= Math.cos(gameState.cameraRotation.y) * speed;
                    gameState.playerVelocity.z += Math.sin(gameState.cameraRotation.y) * speed;
                    break;
                case 'd':
                    // Strafe right
                    gameState.playerVelocity.x += Math.cos(gameState.cameraRotation.y) * speed;
                    gameState.playerVelocity.z -= Math.sin(gameState.cameraRotation.y) * speed;
                    break;
                case ' ':
                    // Reload
                    if (!gameState.reloading && gameState.ammo < gameState.maxAmmo) {
                        gameState.reloading = true;
                        gameState.reloadStart = Date.now();
                    }
                    break;
                case 'shift':
                    // Boost
                    gameState.isBoosting = true;
                    break;
            }
        });
        
        document.addEventListener('keyup', (event) => {
            if (event.key.toLowerCase() === 'shift') {
                gameState.isBoosting = false;
            }
        });
        
        document.addEventListener('mousemove', (event) => {
            if (!gameState.isGameStarted || gameState.isGameOver) return;
            
            // Only handle mouse movement if pointer is locked
            if (document.pointerLockElement === canvas) {
                gameState.cameraRotation.y += event.movementX * 0.002;
                gameState.cameraRotation.x -= event.movementY * 0.002;
                
                // Limit vertical rotation to prevent flipping
                gameState.cameraRotation.x = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, gameState.cameraRotation.x));
            }
        });
        
        document.addEventListener('mousedown', (event) => {
            if (!gameState.isGameStarted || gameState.isGameOver) return;
            
            if (event.button === 0) {  // Left mouse button
                // Only handle clicks if pointer is locked
                if (document.pointerLockElement === canvas) {
                    const now = Date.now();
                    
                    // Check cooldown
                    if (now - gameState.lastShot > gameState.shotCooldown) {
                        fireBullet();
                        gameState.lastShot = now;
                    }
                }
            }
        });
        
        // Handle pointer lock change
        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement !== canvas && gameState.isGameStarted && !gameState.isGameOver) {
                // Pointer was unlocked, show a message or pause the game
                // For simplicity, we'll just relock it
                canvas.requestPointerLock();
            }
        });
        
        // Button event listeners
        document.getElementById('start-button').addEventListener('click', startGame);
        document.getElementById('restart-button').addEventListener('click', restartGame);
        
        // Handle window focus/blur
        window.addEventListener('blur', () => {
            // Stop all movement when window loses focus
            gameState.playerVelocity = { x: 0, y: 0, z: 0 };
        });
        
        // Add mat4.scale function
        mat4.scale = function(out, a, v) {
            const x = v[0], y = v[1], z = v[2];
            
            out[0] = a[0] * x;
            out[1] = a[1] * x;
            out[2] = a[2] * x;
            out[3] = a[3] * x;
            out[4] = a[4] * y;
            out[5] = a[5] * y;
            out[6] = a[6] * y;
            out[7] = a[7] * y;
            out[8] = a[8] * z;
            out[9] = a[9] * z;
            out[10] = a[10] * z;
            out[11] = a[11] * z;
            out[12] = a[12];
            out[13] = a[13];
            out[14] = a[14];
            out[15] = a[15];
            
            return out;
        };
    </script>
</body>
</html>
